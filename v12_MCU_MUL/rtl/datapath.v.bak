// ============================================================================
//  文件名   : datapath.v
//  模块名   : datapath
//  功能描述 : ARM 单周期 CPU 的 **数据通路**
//             ─ 负责完成指令取址、寄存器读写、立即数扩展、ALU 运算、
//               以及分支 / 跳转目标地址计算。
//             ─ 与 controller 交换控制信号，与外部存储器交换数据。
// ----------------------------------------------------------------------------
//  Verilog-2001 迁移要点
//    • SystemVerilog 的  logic → Verilog 的 wire / reg  
//      * 全部内部连线为纯组合 → wire  
//      * 本模块无时序 always 块，故无 reg 变量  
//    • ANSI-style 端口保留，兼容绝大多数 2001 综合 / 仿真工具  
//    • 例化的子模块 (mux2 / adder / extend / regfile / alu / flopr)  
//      均假设已有 Verilog-2001 版本。WIDTH 参数化统一写成 .WIDTH()。
// ----------------------------------------------------------------------------
//  端口列表
//    clk, reset     : 时钟 / 同步复位（高有效）
//    RegSrc[1:0]    : 读寄存器号选择自 controller
//    RegWrite       : 寄存器写使能（已做条件过滤）
//    ImmSrc[1:0]    : 立即数扩展控制
//    ALUSrc         : ALU SrcB 选择：0=WriteData(Rm)，1=ExtImm
//    ALUControl[1:0]: 00=ADD 01=SUB 10=AND 11=ORR
//    MemtoReg       : 0=ALUResult 1=ReadData (写回多路复用)
//    PCSrc          : 0=顺序 PC+4，1=分支 / 跳转目标
//    ALUFlags[3:0]  : {N,Z,C,V}，由 ALU 计算后回送 controller
//    PC             : 对外可见的当前取指地址
//    Instr[31:0]    : 外部（指令存储器）提供的当前指令
//    ALUResult      : ALU 运算结果；对 STR/ LDR 亦作数据存储器地址
//    WriteData      : 写入数据存储器的数值 (Rm)
//    ReadData       : 数据存储器返回的数据 (LDR)
// ============================================================================
module datapath (
  input clk,
  input reset,

  // ==== 来自 controller 的控制信号 =====================================
  input [1:0] RegSrc,      // 读端口寄存器号来源
  input       RegWrite,    // 寄存器写使能
  input [2:0] ImmSrc,      // 立即数扩展控制
  input       ALUSrc,      // ALU SrcB 选择
  input [2:0] ALUControl,  // ALU 运算控制
  input       MemtoReg,    // 写回数据选择
  input       PCSrc,       // PC 源选择 (顺序 / 跳转)

  // ==== 与 controller 的状态返回 =======================================
  output [3:0] ALUFlags,  // N Z C V

  // ==== 与指令存储器接口 ===============================================
  output [31:0] PC,    // 程序计数器
  input  [31:0] Instr, // 取回的指令

  // ==== 与数据存储器接口 ===============================================
  output [31:0] ALUResult,  // 地址 (STR/LDR) 或运算结果
  output [31:0] WriteData,  // 待写入存储器的数据
  input  [31:0] ReadData    // 从存储器读出的数据
);

  // --------------------------------------------------------------------
  // 内部连线（全部为 wire，因本模块只由组合模块+寄存器实例组成）
  // --------------------------------------------------------------------
  wire [31:0] PCNext, PCPlus4, PCPlus8;  // PC 相关
  wire [31:0] ExtImm;  // 扩展后的立即数
  wire [31:0] SrcA, SrcB;  // 送往 ALU 的两路操作数
  wire [31:0] Result;  // 写回寄存器堆的最终结果
  wire [3:0] RA1, RA2;  // 寄存器堆读端口号

  // =========================================================================
  // 1) 程序计数器 PC 及顺序地址 +4、+8 计算
  //    ─ PCNext  = (PCSrc ? Result : PCPlus4)
  //    ─ flopr   : 触发器，WIDTH=32，带同步复位
  // =========================================================================
  mux2 #(
    .WIDTH(32)
  ) pcmux (
    .d0(PCPlus4),  // 顺序执行地址
    .d1(Result),   // 分支 / 跳转目标
    .s (PCSrc),
    .y (PCNext)
  );

  flopr #(
    .WIDTH(32)
  ) pcreg (
    .clk  (clk),
    .reset(reset),
    .d    (PCNext),
    .q    (PC)
  );

  // PCPlus4 = PC + 4
  adder #(
    .WIDTH(32)
  ) pcadd1 (
    .a(PC),
    .b(32'h0000_0004),
    .y(PCPlus4)
  );

  // PCPlus8 = PC + 8 (用于写入 R14／LR 及 LDR 的 PC 相对寻址)
  adder #(
    .WIDTH(32)
  ) pcadd2 (
    .a(PCPlus4),
    .b(32'h0000_0004),
    .y(PCPlus8)
  );

  // =========================================================================
  // 2) 寄存器堆读端口号选择
  //    ─ RA1 = RegSrc[0] ? 4'b1111       : Instr[19:16]   (Rm or PC)
  //    ─ RA2 = RegSrc[1] ? Instr[15:12] : Instr[3:0]     (Rd or Rs)
  // =========================================================================
  mux2 #(
    .WIDTH(4)
  ) ra1mux (
    .d0(Instr[19:16]),  // Rn 或移位寄存器
    .d1(4'b1111),       // PC (R15)
    .s (RegSrc[0]),
    .y (RA1)
  );

  mux2 #(
    .WIDTH(4)
  ) ra2mux (
    .d0(Instr[3:0]),    // Rm
    .d1(Instr[15:12]),  // Rd (当写回数据同时要读)
    .s (RegSrc[1]),
    .y (RA2)
  );

  // =========================================================================
  // 3) 寄存器堆实例
  //    端口: (clk, we3, ra1, ra2, wa, wd, r15_in, rd1, rd2)
  //    - wd      : Result (来自下方 mux)  
  //    - r15_in  : PCPlus8 (供读取 PC 相对地址/BL 链接)
  // =========================================================================
  regfile rf (
    .clk(clk),
    .we3(RegWrite),
    .ra1(RA1),
    .ra2(RA2),
    .wa3(Instr[15:12]),  // Rd
    .wd3(Result),
    .r15(PCPlus8),       // 写入 R15 时取 PC+8
    .rd1(SrcA),
    .rd2(WriteData)      // Rm，用作 STR 数据 & ALU 操作数
  );

  // =========================================================================
  // 4) 立即数扩展模块
  // =========================================================================
  extend ext (
    .Instr (Instr[23:0]),  // 不同指令位宽
    .ImmSrc(ImmSrc),       // 扩展方式
    .ExtImm(ExtImm)
  );

  // =========================================================================
  // 5) ALU 第二操作数选择
  // =========================================================================
  mux2 #(
    .WIDTH(32)
  ) srcbmux (
    .d0(WriteData),  // 来自寄存器 (Rm)
    .d1(ExtImm),     // 扩展后的立即数
    .s (ALUSrc),
    .y (SrcB)
  );

  // =========================================================================
  // 6) 运算单元 ALU
  //    ─ 生成 ALUResult 与 NZCV
  // =========================================================================
  alu alu (
    .a         (SrcA),
    .b         (SrcB),
    .ALUControl(ALUControl),
    .Result    (ALUResult),
    .ALUFlags  (ALUFlags)     // {N,Z,C,V}
  );

  // =========================================================================
  // 7) 写回阶段 MUX
  //    ─ Result = MemtoReg ? ReadData : ALUResult
  // =========================================================================
  mux2 #(
    .WIDTH(32)
  ) resmux (
    .d0(ALUResult),
    .d1(ReadData),
    .s (MemtoReg),
    .y (Result)
  );

endmodule
